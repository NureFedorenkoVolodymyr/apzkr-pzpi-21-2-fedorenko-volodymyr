Міністерство освіти та науки України
Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для автоматизованого управління вітровими електростанціями

Студент гр. ПЗПІ-21-2	__________________ Федоренко В. О.
(підпис)
Керівник роботи	__________________ доц. Лещинський В.О.
(підпис)
	Роботу захищено «__»_________2024 р.
з оцінкою _________________________
Комісія:	__________________  доц. Лещинський В.О.
(підпис)
__________________ доц. Лещинська І.О.
(підпис)
__________________ ст.викл. Сокорчук І.П.
(підпис)

Харків 
2024 р.
 
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук               Кафедра програмної інженерії_____
Спеціальність 121 – Інженерія програмного забезпечення________________
Курс	3	Семестр	6__________________
Навчальна дисципліна Архітектура програмного забезпечення
ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТА
Федоренку Володимиру Олександровичу
1.	Тема роботи: «Програмна система для автоматизованого управління вітровими електростанціями»	
2.	Термін узгодження завдання курсової роботи «26» лютого 2024 р.
3.	Термін здачі студентом закінченої роботи «31» травня 2024 р.
4.	Вихідні дані до проекту (роботи): В програмній системі передбачити:
Необхідно розробити комплексну програмну систему, яка має відповідати ряду критеріїв: оригінальність, потенціал монетизації, актуальність проблематики, орієнтація на широке коло користувачів, масштабованість та міжнародна підтримка. Система повинна включати серверну та клієнтську частини, мобільний застосунок, а також застосунок для IoT або Smart Device. 
5.	Зміст пояснювальної записки (перелік питань, що належить розробити)
вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, кодування програмного проекту, опис розробленої програмної системи, висновки, перелік посилань, додатки	
6.	Перелік графічного матеріалу (з точним зазначенням обов’язкових креслень) UML діаграма розгортання, UML діаграма прецедентів, ER-модель даних, UML діаграма взаємодії, UML діаграма діяльності, UML діаграма компонент	




КАЛЕНДАРНИЙ ПЛАН


Номер	Назва етапів курсової роботи	Строк виконання етапів роботи	Примітки
1	Функціональна специфікація
програмного проекту	31.03.2024	
2	Проектування програмного
проекту	30.04.2024	
3	Кодування програмного проекту	20.05.2024	
4	Оформлення пояснювальної
записки	31.05.2024	
5	Захист курсової роботи	10.06.2024	

Дата видачі завдання «31» березня 2024 р.
Керівник	__________________ доц. Лещинський В.О.
(підпис)

Завдання прийняв до виконання
ст. гр. ПЗПІ-21-2	__________________            Федоренко В.О.
(підпис)

 
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 86 с., 5 рис., 5 додатків, 7 джерел.
ВІТРЯКИ, ЕНЕРГІЯ, УПРАВЛІННЯ, АВТОМАТИЗАЦІЯ, АРХІТЕКТУРА.
Метою роботи є розробка програмної системи для автоматизації управління вітровими електростанціями.
Методи розробки базуються на використанні Microsoft SQL Server Management Studio, ASP.NET Core Web API, платформи .NET Framework 8, контролеру ESP32, веб-фреймворку Angular 17, мобільної платформи .NET MAUI.
Програмна система дозволяє користувачам ефективно керувати власними фермами вітряків, збирати дані про їх роботу, аналізувати зміну показників та отримувати сповіщення.
Для кожного вітряка датчик вимірює швидкість вітру та температуру середовища. На основі цих даних система приймає рішення про зміну режиму роботи окремого вітряка. Також на основі зібраної інформації система підраховує потужність та об’єм виробленої енергії за період вимірювання.
 
ЗМІСТ

ВСТУП	7
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ	8
1.1 Бізнес вимоги	8
1.1.1 Передумови	8
1.1.2 Бізнес-можливості	8
1.1.3 Бізнес-цілі та критерії успіху	10
1.1.4 Потреби клієнтів та ринку	11
1.1.5 Бізнес ризики	12
1.2 Окреслення концепції	13
1.2.1 Окреслення концепції	13
1.2.2 Головна функціональність	13
1.2.3 Припущення та залежності	14
1.3 Рамки та обмеження	15
1.3.1 Рамки первинного випуску	15
1.3.2 Рамки наступних випусків	15
1.3.3 Обмеження та винятки	16
1.4 Бізнес контекст	17
1.4.1 Профілі зацікавлених сторін	17
1.4.2 Пріоритети проекту	18
1.4.3 Робоче середовище	19
2 ПОСТАНОВКА ЗАДАЧІ	20
3 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ	22
4 РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ	23
4.1 Архітектура системи	23
4.2 Розробка серверної частини	23
4.2.1 REST специфікація	23
4.2.2 Розробка сервера	24
4.2.2.1 База даних та підключення	24
4.2.2.2 Структура серверу	25
4.2.2.3 Автентифікація	25
4.2.2.4 Вимірювання та аналіз даних вітряка	26
4.2.2.5 Управління фермами	26
4.2.2.6 Управління вітряками	26
4.2.2.7 Попередження	27
4.2.3 Тестування	27
4.3 Розробка ІоТ девайсу	27
4.3.1 Моделювання	27
4.3.2 Розробка девайсу	28
4.3.2.1 Модуль network_service.py	28
4.3.2.2 Модуль http_service.py	29
4.3.2.3 Модуль profile_service.py	29
4.3.2.4 Модуль wind_sync_service.py	29
4.3.2.5 Модуль constants.py	30
4.4 Розробка веб-застосунку	30
4.4.1 Розробка застосунку	31
4.4.1.1 Компонент FarmsDetailsComponent	31
4.4.1.2 Компонент TurbinesDetailsComponent	31
4.5 Розробка мобільного застосунку	32
4.5.1 Розробка застосунку	32
4.5.1.1 Сервіс ApiService	33
4.5.1.2 Сторінка TurbinesPage	33
ВИСНОВКИ	35
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	36
ДОДАТОК А	37
ДОДАТОК Б	42
ДОДАТОК В	58
ДОДАТОК Г	67
ДОДАТОК Д	76
 
ВСТУП


У сучасному світі стрімкий розвиток відновлюваних джерел енергії, зокрема вітрових електростанцій, став життєво необхідним для забезпечення сталого розвитку та зменшення негативного впливу на навколишнє середовище. Ефективне управління такими електростанціями є важливим завданням, оскільки воно дозволяє оптимізувати виробництво енергії, знижуючи витрати та мінімізуючи ризики несправностей.
Програмна система для автоматизованого управління вітровими електростанціями має на меті забезпечити ефективний моніторинг та оптимізацію роботи всіх компонентів електростанції. Існуючі системи управління часто є громіздкими, складними у використанні та не забезпечують достатнього рівня автоматизації, що призводить до додаткових витрат на обслуговування та зниження продуктивності. Нова система має вирішити ці проблеми, надаючи користувачам інтуїтивно зрозумілий інтерфейс та розширені можливості для автоматичного виявлення відхилень і оперативного прийняття рішень.
Розробка цієї системи включатиме створення серверної та клієнтської частин, мобільного застосунку, а також застосунку для IoT або Smart Device. Важливими аспектами є багатомовний інтерфейс, захист персональних даних та комплекс адміністративних інструментів. Ця система дозволить значно підвищити ефективність використання вітрової енергії та знизити експлуатаційні витрати, що є критичним для сучасних енергетичних підприємств.
Таким чином, розробка програмної системи для автоматизованого управління вітровими електростанціями є необхідним кроком для досягнення високої ефективності, зниження витрат та підвищення надійності роботи енергетичних систем, що використовують відновлювані джерела енергії.
 
1 АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ
1.1 Бізнес вимоги
1.1.1 Передумови

У сучасному світі стрімкий розвиток відновлюваних джерел енергії, таких як вітрові електростанції, став життєво необхідним для забезпечення сталого розвитку та зменшення негативного впливу на навколишнє середовище. Управління вітровими електростанціями вимагає ретельного моніторингу та оптимізації роботи всіх їх компонентів для максимальної ефективності.
Існуючі системи моніторингу та управління вітровими електростанціями часто є громіздкими, складними у використанні та не забезпечують достатньої автоматизації процесів. Це призводить до додаткових витрат на обслуговування, зниження продуктивності та збільшення ризиків виникнення несправностей.
Розробка програмної системи для автоматизованого управління вітровими електростанціями дозволить оптимізувати робочі процеси, підвищити ефективність використання вітрової енергії та знизити експлуатаційні витрати. Така система забезпечить моніторинг ключових параметрів, автоматичне виявлення відхилень та прийняття оперативних рішень щодо регулювання роботи електростанції.

1.1.2 Бізнес-можливості

На ринку існують наступні конкуренти.
1. SCADA-системи:
Найпопулярнішим конкурентом у сфері автоматизованого управління вітровими електростанціями є SCADA-системи. Ці системи пропонують широкий спектр функцій, включаючи моніторинг та контроль вітрових турбін та електростанцій, аналіз даних та прогнозування виробництва енергії, а також управління активами та оптимізацію технічного обслуговування.
Переваги:
-	широкий спектр функцій;
-	досвідчені розробники;
-	глобальна підтримка.
Недоліки:
-	висока вартість;
-	складність у налаштуванні.
2. Системи APM (Asset Performance Management).
Системи APM є другим за популярністю конкурентом. Ці системи фокусуються на управлінні вітровими електростанціями, включаючи планування технічного обслуговування та ремонтів, прогнозування відмов обладнання та оптимізацію запасних частин.
Переваги:
-	гнучкість та адаптивність;
-	широкий спектр модулів;
-	інтеграція з іншими системами.
Недоліки:
-	висока вартість;
-	складність у налаштуванні.
Переваги WindSync над аналогами:
-	Інтуїтивне використання: WindSync надає користувачам зручний і простий інтерфейс для ефективної взаємодії.
-	Гнучкість та налаштування: Система WindSync пропонує широкий спектр налаштувань та персоналізації, що дозволяє користувачам адаптувати її під свої потреби та вимоги.
-	ІoТ інтеграція: Завдяки інтеграції з ІoТ пристроями, WindSync забезпечує користувачам фізичну взаємодію та актуальні дані з електростанцій в реальному часі.
-	Аналітика та звітність: Система надає детальну аналітику та звітність щодо роботи та ефективності електростанцій.
-	Мобільність та доступність: WindSync доступний на різних платформах (Android, iOS) та пристроях.
Модель монетизації:
-	Підписки за розширений функціонал та додаткові можливості.
-	Продаж ІoТ пристроїв для використання їх з електростанціями.
Ринок:
WindSync спрямований на ринок управління електростанціями та енергетичні підприємства, а також на індивідуальних користувачів, які мають інтерес до моніторингу та оптимізації роботи електростанцій. У сучасному енергетичному секторі підвищення ефективності та надійності роботи електростанцій стає все більш важливим завданням, тому інструменти, які пропонує WindSync, можуть бути дуже цінними для цієї аудиторії.
Перспективність:
Зі зростанням використання альтернативних джерел енергії та розвитком смарт-технологій у енергетичній галузі, системи моніторингу та управління електростанціями стають все більш потрібними. WindSync може забезпечити зручний та ефективний інструментарій для енергетичних підприємств та індивідуальних користувачів, допомагаючи вони оптимізувати виробництво енергії, зменшувати витрати та підвищувати загальну надійність систем.

1.1.3 Бізнес-цілі та критерії успіху

BO-1: Створити інтуїтивно зрозумілу та високоефективну програмну систему для автоматизованого управління вітровими електростанціями.
BO-2: Розробити інноваційне рішення, що поєднує програмні можливості з інтеграцією IoT-пристроїв..
BO-3: Забезпечити глобальну доступність та адаптованість системи шляхом створення локалізованих версій, враховуючи мовні особливості різних ринків.
BO-4: Запровадити ефективну модель монетизації.

SC-1: Залучити 10,000 активних користувачів протягом перших 6 місяців після запуску.
SC-2: Реалізувати не менше 500 IoT-пристроїв протягом першого року.

1.1.4 Потреби клієнтів та ринку

Оператори вітрових електростанцій зіштовхуються з постійною необхідністю оптимізації та підвищення ефективності роботи своїх активів. Ключовими потребами цільових клієнтів є:
-	Ефективний моніторинг та контроль роботи вітрових турбін і всіх системних компонентів електростанції в режимі реального часу. Клієнти прагнуть мати швидкий доступ до актуальної інформації для прийняття своєчасних управлінських рішень.
-	Автоматизація рутинних операцій, пов'язаних з регулюванням параметрів роботи електростанції. Це дозволить зменшити навантаження на персонал, підвищити точність та швидкість реагування на зміни.
-	Можливість віддаленого доступу до системи управління електростанцією з різних пристроїв. Це забезпечує гнучкість та мобільність для керівників і технічного персоналу.
-	Простота використання та інтуїтивність інтерфейсу. Клієнти прагнуть легко опановувати нове програмне забезпечення та отримувати максимальну користь без значних зусиль.
Ринок програмних рішень для автоматизації управління вітровими електростанціями перебуває у стадії активного зростання, оскільки галузь відновлюваної енергетики стрімко набирає обертів у всьому світі. Наявність зазначених вище потреб клієнтів створює сприятливі умови для виведення на ринок конкурентоспроможної програмної системи, що зможе ефективно задовольнити попит у цій сфері.
1.1.5 Бізнес-ризики

Реалізація програмної системи для автоматизованого управління вітровими електростанціями пов'язана з низкою потенційних ризиків, які слід ретельно враховувати:
-	Конкуренція на ринку. На ринку вже присутні кілька гравців, які пропонують подібні за функціоналом системи моніторингу та управління вітровими електростанціями. Для утримання конкурентних позицій необхідно постійно вдосконалювати продукт, оперативно реагувати на потреби клієнтів та впроваджувати інноваційні рішення.
-	Технологічні зміни. Галузь відновлюваної енергетики характеризується динамічним розвитком, що супроводжується постійним оновленням обладнання та програмного забезпечення.
-	Складність інтеграції. Успішне впровадження системи потребує ретельної інтеграції з різноманітним обладнанням вітрових електростанцій. Складнощі з інтеграцією можуть призвести до затримок у запуску, збільшення витрат та незадоволеності клієнтів.
-	Кібербезпекові загрози. Як і більшість сучасних ІТ-рішень, система може стати об'єктом кібератак, що може спричинити витоки даних, збої в роботі або навіть вивести з ладу критично важливе обладнання електростанцій.
Для ефективного управління виявленими ризиками потрібно розробити комплексну стратегію, яка включатиме моніторинг ринку, постійне вдосконалення продукту, забезпечення кібербезпеки, налагодження надійної взаємодії з партнерами та підрядниками. Такий підхід дозволить звести до мінімуму негативні наслідки від реалізації бізнес-ризиків. 





1.2 Окреслення концепції

1.2.1 Окреслення концепції

«WindSync» - це інноваційна програмна система, спеціально розроблена для автоматизованого управління вітровими електростанціями та оптимізації їхньої продуктивності. Система поєднує в собі передові технології IoT, аналітики та автоматизації, щоб забезпечити ефективну роботу станцій та максимізувати їхній потенціал.
Основний функціонал системи WindSync включає наступні можливості.
Автоматизоване управління вітровими електростанціями: система надає інтуїтивний інтерфейс для моніторингу та управління параметрами роботи вітрових електростанцій. Користувачі можуть встановлювати та настроювати параметри роботи, отримувати звіти та аналітику ефективності.
Відслідковування та аналітика продуктивності: система відстежує робочий час та продуктивність станцій, надаючи детальну статистику та аналіз для прийняття стратегічних рішень щодо оптимізації робочих процесів.
Інтеграція з IoT пристроями: система підтримує інтеграцію з IoT пристроями для реального часового моніторингу та керування параметрами вітрових електростанцій, що дозволяє забезпечити максимальну ефективність та надійність роботи.

1.2.2 Головна функціональність

MF-1 - Керування режимами роботи: Користувач може встановлювати різні режими роботи для вітрових електростанцій залежно від поточних погодних умов та потреб споживачів електроенергії.
MF-2 - Моніторинг параметрів станцій: Система надає детальну інформацію про роботу кожної вітрової електростанції, включаючи вихідну потужність, швидкість вітру тощо.
MF-3 - Аналіз даних: WindSync збирає та аналізує великий обсяг даних для виявлення тенденцій у роботі станцій, виявлення потенційних проблем та пропозицій щодо оптимізації робочих процесів.
MF-4 - Мобільний доступ: Користувачі мають змогу отримати доступ до системи через мобільний додаток, що дозволяє керувати та моніторити станції в будь-який час та в будь-якому місці.
MF-5 - Сповіщення та повідомлення: Користувачі отримують сповіщення та повідомлення про стан вітрових електростанцій, проблеми та рекомендації щодо їхньої роботи.

1.2.3 Припущення та залежності

DEP-1: Мобільний застосунок WindSync буде розроблений для платформ iOS та Android, щоб забезпечити доступність для широкого кола користувачів сучасних смартфонів та планшетів.
DEP-2: Для безперервної та стабільної роботи системи WindSync необхідний стабільний та надійний доступ до Інтернету. Це важливо для забезпечення обміну даними між мобільним додатком, IoT пристроєм та сервером системи.
DEP-3: Для забезпечення високої якості візуальних елементів та графіки в мобільному додатку WindSync, користувачам може знадобитися сучасний смартфон або планшет з достатньою продуктивністю та підтримкою сучасних графічних технологій.
AS-1: Використання системи WindSync передбачає базові навички користування смартфонами та іншими сучасними пристроями, такі як вміння встановлювати та використовувати мобільні додатки, працювати з інтерфейсами та використовувати основні функції пристроїв.
AS-2: IoT пристрій, що інтегрується з системою WindSync, потребує періодичного заряджання або заміни батареї, щоб забезпечити безперервну роботу та передачу даних.
AS-3: Усі дані користувачів системи WindSync зберігаються на серверах відповідно до встановленої політики конфіденційності та заходів безпеки для забезпечення захисту особистої інформації.
 
1.3 Рамки та обмеження

1.3.1 Рамки первинного випуску

Веб додаток:
-	реєстрація та авторизація користувачів;
-	створення та налаштування профілю користувача;
-	перегляд загальної статистики роботи електростанцій;
-	перегляд історії роботи та діагностичних даних електростанцій;
-	розрахунок ефективності роботи електростанцій.
Мобільний додаток:
-	авторизація та автоматична синхронізація з веб додатком;
-	перегляд статистики та діагностичних даних електростанцій в реальному часі;
-	отримання нагадувань та сповіщень про стан електростанцій та необхідні дії;
IoT пристрій:
-	збір та відправка даних про роботу та стан електростанцій на сервер;
-	вмикання та вимикання електростанції.

1.3.2 Рамки наступних випусків

-	інтеграція з погодними сервісами для автоматичного адаптивного управління електростанціями під змінні погодні умови;
-	розробка механізму автоматичного діагностування та розпізнавання несправностей для швидкого реагування та усунення проблем;
-	впровадження системи прогнозування виробництва електроенергії з використанням штучного інтелекту для оптимізації роботи станцій;
-	опція підключення додаткових датчиків та обладнання для розширення функціональності системи моніторингу.

1.3.3 Обмеження та винятки

-	проект повинен бути завершений і готовий для першого релізу до червня 2024 року згідно з графіком розробки;
-	перший реліз додатка буде доступний лише для платформи Android. Версія для iOS планується в майбутніх оновленнях після оцінки результатів на Android;
-	для доступу до функцій додатку необхідна авторизація користувача, що забезпечить конфіденційність та безпеку даних;
-	у перших етапах роботи, додаток буде обмежено підтримкою до 1,000 активних користувачів, після чого буде необхідно масштабування для збільшення кількості користувачів;
-	панель управління користувачами та платформою буде доступна лише адміністратору системи для забезпечення безпеки та управління доступом до функцій;








1.4 Бізнес-контекст

1.4.1 Профілі зацікавлених сторін

Опис профілів зацікавлених сторін наведено у таблиці 1.4.1.

Таблиця 1.4.1 – Профілі зацікавлених сторін
Зацікавлена сторона	Обмеження	Основні інтереси	Ставлення до програмного продукту	Основна цінність
Компанії-клієти	Наявність стабільного Інтернет-з'єднання, необхідність інтеграції з існуючим обладнанням	Підвищення ефективності роботи електростанцій, зручність в управлінні та звітності	Очікується, що продукт буде простим у використанні та надійним	Можливість підвищення продуктивності електростанцій
Інвестори	Фінансові ризики, показники прибутковості	Повернення інвестицій, зростання компанії	Очікується, що проект забезпечить зростання прибутковості та має стабільний фінансовий план	Забезпечення повернення інвестицій та зростання прибутковості
Розробник	Технічні обмеження, доступ до необхідних ресурсів	Створення якісного продукту, розвиток технологій	Очікується, що в проекті буде детально описана технічна специфікація та буде можливість оптимізації функціоналу	Створення якісного продукту та його оптимізація

1.4.2 Пріоритети проекту

У процесі реалізації проекту "WindSync" було визначено ключові пріоритети, які відображають головні напрямки та обмеження, на які орієнтуються команда і усі зацікавлені сторони (табл. 1.4.2).

Таблиця 1.4.2 – Ключові пріоритети проекту
Критерій	Опис	Пріоритет
Вимоги до функціоналу		Забезпечення повного набору функцій, який допоможе користувачам підвищити ефективність роботи	Високий
Графік робіт	Перший реліз проекту планується на червень 2024		Високий
Бюджет	Розробка з обмеженим бюджетом, але з можливістю додаткового фінансування в межах 10%	Середній
Розмір команди	Фіксований розмір команди для ефективного виконання завдань	Високий
Незавершеність проекту	Максимально 15% незавершених основних функцій до часу випуску	Низький
Якість та безпека продукту	Забезпечення високих стандартів якості, безпеки, використання сучасних методів шифрування та автентифікації	Високий

1.4.3 Робоче середовище

-	програмні платформи:
-	мобільна платформа: .NET MAUI
-	веб-платформа: Angular
-	IoT: Raspberry Pi Emulator
-	Серверна частина: ASP.NET Core Web API
-	СУБД: Microsoft SQL Server Management Studio
-	фреймворки:
-	Backend: ASP.NET Core
-	Frontend: Angular
-	мови програмування: C#, Typescript, HTML, CSS, Python
-	вимоги до системи:
-	доступність: додаток повинен забезпечувати 99.9% доступність для користувачів.
-	надійність: резервне копіювання даних щоденно, відновлення даних протягом 4 годин у випадку збою.
-	продуктивність: завантаження додатка та відгук на користувацькі дії має бути менше 2 секунд.
-	цілісність: хешування паролів, автентифікація за поштою, шифрування даних на сервері.
 
2 ПОСТАНОВКА ЗАДАЧІ

В результаті проведеного аналізу предметної області було сформовано мету. Необхідно спроектувати та реалізувати програмну систему для автоматизації управління вітровими електростанціями. Для демонстрації функціоналу системи та його розподіл за ролями користувачів було розроблено UML діаграму прецедентів (див. А.1).
Програмна система повинна містити наступні можливості:
-	взаємодія з особистим акаунтом:
-	реєстрація у системі;
-	вхід/вихід з системи;
-	перегляд інформації профілю.
-	взаємодія з власними фермами:
-	перегляд власні ферми;
-	додавання/редагування/видалення ферми;
-	перегляд їх детальної інформації;
-	перегляд списку вітряків ферми та статистики їх роботи.
-	взаємодія з вітряками:
-	перегляд власні вітряки;
-	додавання/редагування/видалення вітряків;
-	перегляд інформації про вітряк, статистику його роботи, об’єм виробленої енергії.
-	перегляд попереджень:
-	перегляд попереджень в системі про зміни в режимах роботи вітряка.
-	відправка даних вітряка:
-	автоматичне отримання даних з датчиків вітряка.
-	функціонал адміністратора:
-	управління системою:
-	додавання адміністраторів;
-	видалення ферми;
-	видалення вітряка;
-	видалення користувачів.
-	перегляд стану системи:
-	перегляд усіх ферм;
-	перегляд усіх вітряків. 
3 ПРОЕКТУВАННЯ БАЗИ ДАНИХ

Для проектування структури бази даних програмної системи було розроблено ER діаграму (див. А.2).
База даних міститиме 5 таблиць та 25 неключових атрибутів:
-	Users: таблиця з інформацією про користувачів системи;
-	Alerts: таблиця з попередженнями для користувачів;
-	WindFarms: таблиця з даними про вітряні ферми;
-	Turbines: таблиця з інформацією про вітряки;
-	TurbineData: таблиця з записами вимірювань датчиків для вітряків.
Нижче наведено детальний опис усіх зв’язків між таблицями в базі даних:
-	Один користувач може мати багато ферм, але одна ферма належить лише одному користувачу;
-	Один користувач може мати безліч попереджень, але одне попередження може належати лише одному користувачу;
-	Одна ферма може містити багато вітряків, але один вітряк належить лише одній фермі;
-	Один вітряк може мати безліч записів даних, але один запис може належати лише одному вітряку.
 
4 РОЗРОБКА ПРОГРАМНОЇ СИСТЕМИ
4.1 Архітектура системи

Для початку роботи було розроблено UML діаграму розгортання (див. А.3). Програмна система міститиме 5 структурних частин:
-	серверна частина;
-	база даних;
-	веб-застосунок;
-	мобільний застосунок;
-	IoT девайс.
З використанням діаграми було визначено зв’язки між вищезазначеними структурними частинами, а також протоколи їх взаємодії між собою.

4.2 Розробка серверної частини

4.2.1 REST специфікація

Контролер Alerts (попередження):
-	GET /api/alerts: отримує всі попередження.
Контролер Auth (автентифікація):
-	POST /api/auth/login: виконує вхід користувача;
-	POST /api/auth/register: реєструє нового користувача;
-	POST /api/auth/register-admin: реєструє нового адміністратора;
-	GET /api/auth/test: тестує автентифікацію;
Контролер TurbineData (дані вітряків):
-	POST /api/turbinedata: додає дані вітряка;
-	DELETE /api/turbinedata/{dataId}: видаляє дані вітряка за ID.
Контролер Turbines (вітряки):
-	GET /api/turbines: отримує всі вітряки;
-	POST /api/turbines: додає новий вітряк;
-	GET /api/turbines/{turbineId}: отримує вітряк за ID;
-	PUT /api/turbines/{turbineId}: оновлює вітряк за ID;
-	DELETE /api/turbines/{turbineId}: видаляє вітряк за ID;
-	POST /api/turbines/{turbineId}/status: оновлює статус вітряка за ID;
-	GET /api/turbines/{turbineId}/data: отримує дані вітряка за ID та період;
-	GET /api/turbines/{turbineId}/data/recent: отримує останні дані вітряка за ID.
Контролер WindFarms (ферми):
-	GET /api/windfarms: отримує всі ферми;
-	POST /api/windfarms: додає нову ферму;
-	GET /api/windfarms/{farmId}: отримує ферму за ID;
-	PUT /api/windfarms/{farmId}: оновлює ферму за ID;
-	DELETE /api/windfarms/{farmId}: видаляє ферму за ID;
-	GET /api/windfarms/{farmId}/turbines: отримує всі вітряки ферми за ID.

4.2.2 Розробка сервера

Для розробки серверної частини було використано ASP.NET Core Web API разом із мовою програмування C#. У якості середовища розробки застосовувалася Visual Studio 2022.

4.2.2.1 База даних та підключення

Для роботи з базою даних було використано Microsoft SQL Server Management Studio. Для взаємодії з базою даних з серверної частини було використано Entity Framework Core.
Для створення таблиць в базі даних було використано code-first підхід: створено класи в програмі та використано міграції на підключену базу даних.

4.2.2.2 Структура серверу

Бекенд поділено на 4 основних проекти:
-	PL (Web API) – містить контролери;
-	BLL (Class Library) – містить сервіси з бізнес логікою;
-	DAL (Class Library) – містить репозиторії для взаємодії з базою даних;
-	Core (Class Library) – містить класи основних моделей системи.
Контролери виступають точкою входу на сервер. Вони здійснюють первинну валідацію даних, після отримання запиту від клієнту контролери передають управління сервісам. Сервіси відповідають за бізнес логіку додатку, проводячи необхідні маніпуляції з об’єктами системи. Для взаємодії з базою даних сервіси використовують репозиторії, які вже безпосередньо підтримують зв’язок з базою даних через Entity Framework.

4.2.2.3 Автентифікація

Під час реєстрації новий користувач записується до бази даних (див. Б.1, рядок 56 - 87). Також зберігається роль користувача (UserRoles.User або UserRoles.Admin) в залежності від типу реєстрації (RegisterAsync або RegisterAdminAsync). Пароль користувача хешується за допомогою UserManager, і в базі зберігається лише хеш, для забезпечення безпеки.
Під час входу в систему (LoginAsync) метод перевіряє, чи існує користувач з введеною електронною адресою та чи правильний введений пароль (див. Б.1, рядок 29 - 35). Якщо дані коректні, створюється JWT-токен, який містить унікальний ідентифікатор (Guid), ім'я користувача та ролі (див. Б.1, рядок 36 - 51). Цей токен використовується для відстеження сесії користувача після успішного входу.
Метод GetToken створює JWT-токен з відповідними вимогами (claims) та підписує його за допомогою секретного ключа даних (див. Б.1, рядок 138 - 154).

4.2.2.4 Вимірювання та аналіз даних вітряка

IoT девайс з певною періодичністю вимірює температуру навколишнього середовища та швидкість вітру. Ці дані надсилаються на сервер, де відбувається обробка. Перед записом цієї інформації до бази даних підраховується тиск повітря, його щільність, потужність вітряка в момент вимірювання, а також вироблена енергія за період даних (див. Б.2, рядок 41 - 108).
Далі на основі отриманих даних аналізується, чи потрібно змінювати режим роботи вітряка (див. Б.2, рядок 23 - 191). Якщо швидкість вітру в нормі, то вітряк перемикається в робочий (Operational) режим. Якщо швидкість вітру менша або більша за критичні значення для вітряка, то він перемикається в неробочий (Idle) режим. Користувач отримує попередження про зміну режиму роботи.

4.2.2.5 Управління фермами

Користувач має можливість створити, відредагувати чи видалити ферму. Також користувач може переглянути свої ферми, детальну інформацію за фермою чи список вітряків ферми.

4.2.2.6 Управління вітряками

Користувач має можливість створити, відредагувати чи видалити вітряк. Також користувач може переглянути свої вітряки, детальну інформацію за вітряком.
Також для кожного вітряка доступна статистика його роботи, зокрема вихідна потужність та кількість виробленої енергії за період.




4.2.2.7 Попередження

Користувач може переглядати список своїх попереджень та оперативно реагувати на зміни в станах та режимах вітряків.

4.2.3 Тестування

Для тестування функціональності сервера його можливості було протестовано з використанням Open API Swagger. Було визначено, що функціонал системи працює правильно та стабільно.

4.3 Розробка ІоТ девайсу

4.3.1 Моделювання

Користувач пристрою має можливість налаштовувати підключення до мережі Інтернет, входити до системи, змінювати поточний вітряк та період вимірювання даних, запускати вимірювання інформації з датчиків.
Повний цикл роботи описано нижче:
-	Система пропонує користувачеві налаштувати підключення до мережі. Тут користувач може змінити SSID та пароль Wi-Fi, або видалити пароль (якщо точка доступу не має паролю).
-	Після цього користувач може увійти до свого профілю. Якщо автентифікація успішна, то користувач може починати роботу з пристроєм.
-	На екран виводиться ідентифікатор поточного вітряка та період вимірювання даних. Користувач може почати вимірювати інформацію або налаштувати один з двох параметрів.
-	Після запуску вимірювання система через певний заданий проміжок часу отримує значення температури та швидкості вітру з датчиків та надсилає їх на сервер, де відбувається їх поточна обробка.
4.3.2 Розробка девайсу

Програмне забезпечення для пристрою IoT було розроблено на мові  програмування MicroPython у симуляторі Wokwi. Було використано мікроконтролер Arduino ESP32, який має можливість підключення до мережі та виходу в мережу Інтернет, датчик температури та вологості (використовується як датчик швидкості вітру). 
У програмі використовуються HTTP-запити для взаємодії з серверною частиною, здійснювані за допомогою модуля urequests, який дозволяє реалізувати GET і POST запити до API. Також використовується модуль dht для взаємодії з датчиком.
Перед початком написання коду для IoT-пристрою було створено програмну схему, що описує взаємодію між його компонентами: контролером, сенсорами та серверною частиною (див. А.4). У коді використовуються глобальні змінні для зберігання даних сенсорів, мережевих налаштувань, параметрів частоти вимірювання, а також для зберігання інформації про поточного користувача та серверну частину.
Програма починається з ініціалізації основного сервісу WindSyncService та виклику його основної функції main().

4.3.2.1 Модуль network_service.py

Модуль network_service.py відповідає за підключення до мережі Wi-Fi та налаштування мережевих параметрів.
Ініціалізація Wi-Fi модуля відбувається у класі NetworkService (див. В.1, рядок 5 - 7). Функція connect_to_network() підключається до Wi-Fi мережі, використовуючи задані SSID та пароль. Вона включає цикл для очікування підключення (див. В.1, рядок 9 - 18). Функція configure_network() забезпечує інтерфейс для зміни налаштувань Wi-Fi (див. В.1, рядок 20 - 38), включаючи зміну SSID (див. В.1, рядок 40 - 46), зміну пароля (див. В.1, рядок 48 - 54) та видалення пароля (див. В.1, рядок 56 - 61).

4.3.2.2 Модуль http_service.py

Модуль http_service.py відповідає за взаємодію з сервером через HTTP-запити. Клас HttpService містить функції для автентифікації та надсилання даних на сервер.
Функція login() здійснює POST-запит для входу в систему з використанням email та пароля (див. В.2, рядок 11 - 33). Функція get_my_turbines() отримує список вітряків користувача (див. В.2, рядок 35 - 49). Функція add_turbine_data() відправляє дані про температуру та швидкість вітру для конкретного вітряка (див. В.2, рядок 51 - 79).

4.3.2.3 Модуль profile_service.py

Модуль profile_service.py відповідає за збереження інформації профілю користувача, такої як токен доступу та ідентифікатор вітряка.
Клас ProfileService містить методи для встановлення токену доступу, ідентифікатора вітряка та статусу вітряка (див. В.3, рядок 3 - 15).

4.3.2.4 Модуль wind_sync_service.py

Модуль wind_sync_service.py реалізує основний функціонал програми. Клас WindSyncService ініціалізує необхідні сервіси та датчик DHT22 (див. В.4, рядок 9 - 14).
Функція main() надає користувачу інтерфейс для вибору налаштувань мережі або входу в систему (див. В.4, рядок 16 - 32). Функція __login() відповідає за підключення до мережі та автентифікацію (див. В.4, рядок 34 - 49). Функція __configuration() надає інтерфейс для вибору дій після автентифікації, таких як початок логування даних (див. В.4, рядок 51 - 61). Функція __change_turbine_id() та __change_logging_period() дозволяють змінити ідентифікатор вітряка та період логування відповідно (див. В.4, рядок 73 - 94). Функція __start_logging() відповідає за зчитування даних з датчика, їх обробку та відправку на сервер в циклі (див. В.4, рядок 96 - 124).

4.3.2.5 Модуль constants.py

Модуль constants.py містить постійні значення, які використовуються у програмі, такі як налаштування мережі, URL API та інтервали логування.

4.4 Розробка веб-застосунку

Для розробки клієнтської частини було використано фреймворк Angular 17, мову програмування Typescript та мови HTML та CSS.
Для дизайну застосовується бібліотека Angular Material. Для зображення графіків використовується бібліотека ApexCharts.
Проект має наступну структуру:
-	Components – відповідають за представлення в системі;
-	Guards – обмежують доступ користувачів до певних шляхів;
-	Interceptors – додає токен авторизації до кожного запиту;
-	Services – відповідають за взаємодію з сервером;
-	Assets – містять в собі статичні файли (зображення), а також основні моделі системи.
Клієнтська частина взаємодіє з сервером ASP.NET Web Api з використанням HTTP-запитів, таких як GET, POST, PUT, DELETE.




4.4.1 Розробка застосунку
	
Основний функціонал системи – перегляд інформації про ферми та вітряки. Робота компонентів, що відповідають за це, відбувається в наступному порядку.

4.4.1.1 Компонент FarmsDetailsComponent

Використовуються Angular ін'єкції для сервісів FarmService, AuthService, TurbineService, Router, ActivatedRoute та MatDialog (див. Г.1 , рядок 29 - 34).
Оголошуються змінні для зберігання даних про ферму (farm), список вітряків (turbines), кількість операційних вітряків (operationalTurbinesCount), зведені дані про вітрякіи (turbinesCombinedData), колонки для відображення в таблиці (turbinesDisplayedColumns, turbinesColumnNames, turbinesDisplayed ColumnsWithExpand) та змінна для розширеного вітряка (expandedTurbine) (див. Г.1 , рядок 38 - 68).
Метод ngOnInit виконується під час ініціалізації компонента. Отримує ідентифікатор ферми з маршруту, перевіряє, чи користувач є адміністратором, завантажує дані про ферму та вітряки за допомогою відповідних сервісів, обчислює кількість працюючих вітряків та викликає метод getStats для обчислення статистичних даних (див. Г.1 , рядок 70 - 88).
Метод getStats обчислює середню швидкість вітру, середню номінальну потужність та загальну потужність вітряків за певний період часу (початок і кінець дня). Використовує метод forkJoin для паралельного запиту історичних даних для кожного вітряка та обчислює середні значення на основі отриманих даних (див. Г.1 , рядок 90 - 131).

4.4.1.2 Компонент TurbinesDetailsComponent

Метод ngOnInit виконується під час ініціалізації компонента. Перевіряє, чи користувач є адміністратором, завантажує історичні дані про вітряки за допомогою TurbineService, сортує їх за датою та оновлює графік (див. Г.2 , рядок 31 - 49).
Метод updateChart оновлює налаштування графіку на основі отриманих даних про вітряк. Встановлює серію даних для графіку, тип графіку, налаштування осей, підписи, криву та формат відображення даних (див. Г.2 , рядок 76 - 129).

4.5 Розробка мобільного застосунку

Для розробки клієнтської частини було використано платформу .NET MAUI, мову програмування C# та мову розмітки XAML.
Проект має наступну структуру:
-	Models – містить в собі основні моделі системи;
-	Platforms – службова директорія, містить файли для кожної з підтримуваних платформ;
-	Resources – містить в собі основні ресурси: шрифти, стилі, зображення тощо;
-	Services – містить основні сервіси, що використовуються в додатку;
-	Utils – містить в собі допоміжні класи;
-	Views – містить в собі сторінки додатку.
Клієнтська частина взаємодіє з сервером ASP.NET Web Api з використанням HTTP-запитів, таких як GET та POST.

4.5.1 Розробка застосунку
	
Основний функціонал системи – перегляд інформації про вітряки та повідомлення.



4.5.1.1 Сервіс ApiService

Сервіс містить логіку взаємодії з сервером через HTTP запити. Клас ApiService реалізує інтерфейс IApiService, що забезпечує методи для взаємодії з API сервера. Конструктор ініціалізує HttpClient для виконання HTTP запитів, встановлює базову адресу API залежно від платформи (Android чи інша), та встановлює параметри серіалізації JSON з політикою іменування CamelCase (див. Д.1, рядок 20 - 33).
Метод GetTurbineDataAsync є асинхронним методом, який отримує дані про вітряк за заданий період. Він перевіряє наявність інтернет-з'єднання, встановлює токен авторизації у заголовки запиту, виконує HTTP GET запит до API для отримання даних, та десеріалізує відповідь у список об'єктів TurbineData (див. Д.1, рядок 113 - 145). Інші методи включають LoginAsync (див. Д.1, рядок 35 - 68), який виконує авторизацію користувача, IsAuthenticated (див. Д.1, рядок 70 - 77), що перевіряє, чи користувач аутентифікований, GetMyTurbinesAsync (див. Д.1, рядок 79 - 111), який отримує список вітряків, що належать користувачу, GetUserProfileAsync (див. Д.1, рядок 147 - 180), який отримує інформацію про профіль користувача, та GetMyAlertsAsync (див. Д.1, рядок 182 - 215), який отримує список попереджень для користувача. Допоміжні методи включають GetAuthToken (див. Д.1, рядок 217 - 222) для отримання токена авторизації з захищеного сховища, CheckInternetConnection (див. Д.1, рядок 224 - 235) для перевірки наявності інтернет-з'єднання, HandleException (див. Д.1, рядок 237 - 241) для обробки виключень, що виникають під час запитів, та CheckHttpRequestSuccess (див. Д.1, рядок 243 - 259) для перевірки успішності HTTP запитів.

4.5.1.2 Сторінка TurbinesPage

C# файл містить логіку роботи сторінки, включаючи завантаження даних та обробку подій. Клас TurbineDetailsPage наслідує ContentPage і реалізує інтерфейс INotifyPropertyChanged для підтримки двостороннього зв'язку даних. Основні поля та властивості включають _apiService, яке є приватним полем для зберігання екземпляра сервісу API, використовуваного для взаємодії з сервером, Turbine, яке є полем для зберігання інформації про поточний вітряк, та _turbineData і TurbineData, які є властивостями з підтримкою повідомлень про зміни для зберігання та відображення даних вітряка (див. Д.2, рядок 9 - 26).
Конструктор сторінки ініціалізує компоненти сторінки та встановлює контекст даних, ініціалізує _apiService за допомогою нового екземпляра ApiService та створює порожній ObservableCollection для TurbineData. Також викликає метод SetTurbineLabels, щоб заповнити елементи інтерфейсу відповідними значеннями (див. Д.2, рядок 28 - 41). Подія OnAppearing є перевантаженим методом, який викликається при відображенні сторінки, та викликає асинхронний метод LoadData для завантаження даних про вітряк з сервера (див. Д.2, рядок 43 - 48).
Метод LoadData є асинхронним методом, який визначає початок і кінець періоду (останні два місяці) для запиту даних, викликає метод GetTurbineDataAsync сервісу _apiService для отримання даних вітряка за вказаний період, очищує поточну колекцію TurbineData та додає нові отримані дані (див. Д.2, рядок 50 - 63). Метод SetTurbineLabels встановлює значення елементів інтерфейсу для відображення атрибутів вітряка (ідентифікатор, статус, радіус, площа охоплення, широта, довгота, висота, ефективність) (див. Д.2, рядок 65 - 82). Метод OnPropertyChanged викликається при зміні значення властивості, щоб повідомити інтерфейс про зміни (див. Д.2, рядок 84 - 92).
 
ВИСНОВКИ

Головною метою курсової роботи було створення програмної системи, що полегшить процес управління та відслідковування роботи вітрових електростанцій.
Першим етапом було здійснено детальний аналіз предметної області та сформовано основні задачі майбутньої системи. Також було виділено основні сутності, що наявні в даній предметній області.
У результаті роботи було створено програмну систему, що відповідає усім вимогам та задачам, описаним у курсовій роботі.
Система складається з окремих структурних частин, що взаємодіють між собою. Система надає користувачам можливість керувати фермами вітряків, окремими вітряками, переглядати графіки та статистику їх роботи, робити заміри необхідних даних з використанням ІоТ девайсу та переглядати об’єм енергії, що виробили вітряки.
У результаті розробки програмної системи була підготовлена пояснювальна записка, що містить детальний опис та документацію створеної системи. Пояснювальна записка відповідає наданим методичним вказівкам та детально описує можливості, структуру, архітектуру, процес проектування, технології та підходи, що були використані у процесі розробки.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1.	Репозиторій проекту. GitHub. URL: https://github.com/NureFedorenkoVolodymyr/apzkr-pzpi-21-2-fedorenko-volodymyr (дата звернення: 09.06.2024).
2.	Репозиторій проекту. GitHub. URL: https://github.com/NureFedorenkoVolodymyr/apzkr-pzpi-21-2-fedorenko-volodymyr (дата звернення: 09.06.2024).
3.	ASP.NET documentation. Microsoft Learn. URL: https://learn.microsoft.com/en-us/aspnet/core/?view=aspnetcore-8.0 (date of access: 09.06.2024).
4.	Angular Documentation. Angular. URL: https://angular.dev/ (date of access: 09.06.2024).
5.	Wokwi Documentation. Wokwi Docs. URL: https://docs.wokwi.com/ (date of access: 09.06.2024).
6.	.NET Multi-platform App UI documentation. Microsoft Learn. URL: https://learn.microsoft.com/en-us/dotnet/maui/?view=net-maui-8.0 (date of access: 09.06.2024).
7.	Методичні вказівки до курсової роботи з навчальної дисципліни «Архітектура програмного забезпечення» для студентів усіх форм навчання спеціальності 121 – «Інженерія програмного забезпечення» [Електронне видання] / Упоряд. В.О. Лещинський, І.О. Лещинська, І.П. Сокорчук – Харків: ХНУРЕ, 2021. – 37 с.
ДОДАТОК А
Діаграми

А.1 UML діаграма прецедентів

 
 







 
А.2 ER-модель даних

  
А.3 UML діаграма розгортання

 

 
А.4 Схема ІоТ девайсу

 
 
ДОДАТОК Б
Код сервера

Б.1 Код сервісу AuthService

1 using Microsoft.AspNetCore.Identity;
2 using Microsoft.IdentityModel.Tokens;
3 using System.IdentityModel.Tokens.Jwt;
4 using System.Security.Claims;
5 using System.Text;
6 using WindSync.BLL.Dtos;
7 using WindSync.BLL.Utils;
8 using WindSync.Core.Enums;
9 using WindSync.Core.Models;
10 
11 namespace WindSync.BLL.Services.Auth;
12 
13 public class AuthService : IAuthService
14 {
15     private readonly UserManager<User> _userManager;
16     private readonly RoleManager<IdentityRole> _roleManager;
17     private readonly JwtConfiguration _configuration;
18 
19     public AuthService(
20             UserManager<User> userManager,
21             RoleManager<IdentityRole> roleManager,
22             JwtConfiguration configuration)
23     {
24         _userManager = userManager;
25         _roleManager = roleManager;
26         _configuration = configuration;
27     }
28 
29     public async Task<JwtSecurityToken?> LoginAsync(LoginDto model)
30     {
31         var user = await _userManager.FindByEmailAsync(model.Email);
32         if (user is not null && await _userManager.CheckPasswordAsync(
33 						user,
34 						model.Password))
35         {
36             var userRoles = await _userManager.GetRolesAsync(user);
37 
38             var authClaims = new List<Claim>
39                 {
40                     new Claim(ClaimTypes.Name, user.UserName),
41                     new Claim(JwtRegisteredClaimNames.Jti,
42 			Guid.NewGuid().ToString()),
43                 };
44 
45             foreach (var userRole in userRoles)
46             {
47                 authClaims.Add(new Claim(ClaimTypes.Role, userRole));
48             }
49 
50             return GetToken(authClaims);
51         }
52 
53         return null;
54     }
55 
56     public async Task<bool> RegisterAsync(RegisterDto model)
57     {
58         var userExists = await _userManager.FindByNameAsync(
59 					model.Username);
60         if (userExists is not null)
61             return false;
62 
63         User user = new()
64         {
65             Email = model.Email,
66             SecurityStamp = Guid.NewGuid().ToString(),
67             UserName = model.Username
68         };
69         var result = await _userManager.CreateAsync(user,
70 					model.Password);
71         if (!result.Succeeded)
72             return false;
73 
74         if (!await _roleManager.RoleExistsAsync(
75 			UserRoles.User.ToString()))
76             await _roleManager.CreateAsync(
77 			new IdentityRole(UserRoles.User.ToString()));
78 
79         if (await _roleManager.RoleExistsAsync(
80 		UserRoles.User.ToString()))
81         {
82             await _userManager.AddToRoleAsync(
83 		user, UserRoles.User.ToString());
84         }
85 
86         return true;
87     }
88 
89     public async Task<bool> RegisterAdminAsync(RegisterDto model)
90     {
91         var userExists = await _userManager.FindByNameAsync(
92 		model.Username);
93         if (userExists is not null)
94             return false;
95 
96         User user = new()
97         {
98             Email = model.Email,
99             SecurityStamp = Guid.NewGuid().ToString(),
100             UserName = model.Username
101         };
102         var result = await _userManager.CreateAsync(
103 		user,
104 		model.Password);
105         if (!result.Succeeded)
106             return false;
107 
108         if (!await _roleManager.RoleExistsAsync(
109 		UserRoles.Admin.ToString()))
110             await _roleManager.CreateAsync(
111 		new IdentityRole(UserRoles.Admin.ToString()));
112         if (!await _roleManager.RoleExistsAsync(
113 		UserRoles.User.ToString()))
114             await _roleManager.CreateAsync(
115 		new IdentityRole(UserRoles.User.ToString()));
116 
117         if (await _roleManager.RoleExistsAsync(
118 		UserRoles.Admin.ToString()))
119         {
120             await _userManager.AddToRoleAsync(
121 		user, UserRoles.Admin.ToString());
122         }
123         if (await _roleManager.RoleExistsAsync(
124 		UserRoles.User.ToString()))
125         {
126             await _userManager.AddToRoleAsync(
127 		user, UserRoles.User.ToString());
128         }
129 
130         return true;
131     }
132 
133     public async Task<User> GetUserByUsernameAsync(string username)
134     {
135         return await _userManager.FindByNameAsync(username);
136     }
137 
138     private JwtSecurityToken GetToken(List<Claim> authClaims)
139     {
140         var authSigningKey = new SymmetricSecurityKey(
141 		Encoding.UTF8.GetBytes(
142 		_configuration.Key));
143 
144         var token = new JwtSecurityToken(
145             issuer: _configuration.Issuer,
146             audience: _configuration.Audience,
147             expires: DateTime.Now.AddHours(3),
148             claims: authClaims,
149             signingCredentials: new SigningCredentials(
150 		authSigningKey,
151 		SecurityAlgorithms.HmacSha256)
152             );
153 
154         return token;
155     }
156 }



Б.2 Код сервісу TurbineDataService

1 using AutoMapper;
2 using WindSync.BLL.Dtos;
3 using WindSync.Core.Enums;
4 using WindSync.Core.Models;
5 using WindSync.Core.Utils;
6 using WindSync.DAL.Repositories.TurbineDataRepository;
7 using WindSync.DAL.Repositories.TurbineRepository;
8 
9 namespace WindSync.BLL.Services.TurbineDataService;
10 
11 public class TurbineDataService : ITurbineDataService
12 {
13     private readonly ITurbineDataRepository
14 	_turbineDataRepository;
15     private readonly ITurbineRepository _turbineRepository;
16     private readonly ITurbineDataHelper _turbineDataHelper;
17     private readonly IMapper _mapper;
18 
19     public TurbineDataService(
20         ITurbineDataRepository repository,
21         ITurbineRepository turbineDataRepository,
22         ITurbineDataHelper turbineDataHelper,
23         IMapper mapper
24         )
25     {
26         _turbineDataRepository = repository;
27         _turbineRepository = turbineDataRepository;
28         _turbineDataHelper = turbineDataHelper;
29         _mapper = mapper;
30     }
31 
32     public async Task<TurbineStatus>
33 	AddDataAsync(TurbineDataDto data)
34     {
35         var model = _mapper.Map<TurbineData>(data);
36         var turbine = await _turbineRepository
37 	.GetTurbineByIdAsync(model.TurbineId);
38         var recentData = await _turbineRepository
39 	.GetMostRecentTurbineDataAsync(model.TurbineId);
40 
41         // Calculate air pressure (P)
42         // Formula: P = P0 * e ^
43 	((-u * g * h) / (R * T))
44         // P0 - sea level air pressure
45         // u - molar mass of air
46         // g - acceleration of gravity
47         // h - altitude
48         // R - universal gas constant
49         // T - air temperature
50         model.AirPressure = Constants.SeaLevelPressure *
51 	Math.Exp(-Constants.MolarMassOfAir *
52 	Constants.AccelerationOfGravity * turbine.Altitude
53 	/ (Constants.UniversalGasConstant * model.AirTemperature));
54 
55         // Calculate air density (p)
56         // Formula: p = P / (R * T)
57         // P - air pressure
58         // R - gas constant
59         // T - air temperature
60         model.AirDensity = model.AirPressure /
61 	(Constants.GasConstantForAir * model.AirTemperature);
62 
63         // Calculate rated power and average rated power
64 	(P and Pavg)
65         // Formula: P = 1/2 * p * A * V^3
66         // p - air density
67         // A - swept area
68         // V - wind speed
69         var currentWindSpeed = model.WindSpeed;
70         if (_turbineDataHelper.IsBelowCutInWindSpeed(
71 		turbine, model.WindSpeed)
72             || _turbineDataHelper.IsShutDownWindSpeed(
73 		turbine, model.WindSpeed))
74             currentWindSpeed = 0;
75         else if (_turbineDataHelper.IsRatedWindSpeed(
76 		turbine, model.WindSpeed))
77             currentWindSpeed = turbine.RatedWindSpeed;
78 
79         model.RatedPower = model.AirDensity * turbine.SweptArea *
80 	Math.Pow(currentWindSpeed, 3) / 2 * turbine.Efficiency;
81 
82         if(recentData is not null)
83         {
84             var recentWindSpeed = recentData.WindSpeed;
85             if (_turbineDataHelper.IsBelowCutInWindSpeed(
86 		turbine, recentData.WindSpeed)
87                 || _turbineDataHelper.IsShutDownWindSpeed(
88 		turbine, recentData.WindSpeed))
89                 recentWindSpeed = 0;
90             else if (_turbineDataHelper.IsRatedWindSpeed(
91 		turbine, recentData.WindSpeed))
92                 recentWindSpeed = turbine.RatedWindSpeed;
93 
94             var avgAirDensity = (model.AirDensity +
95 		recentData.AirDensity) / 2;
96             var avgWindSpeed = (currentWindSpeed +
97 		recentWindSpeed) / 2;
98             var Pavg = avgAirDensity * turbine.SweptArea *
99 		Math.Pow(avgWindSpeed, 3) / 2 * turbine.Efficiency;
100 
101             // Calculate power output (Po)
102             // Formula: Po = Pavg * (t2 - t1)
103             // Pavg - average rated power
104             // t2 - current time
105             // t1 - most recent record time
106             model.PowerOutput = Pavg * (model.DateTime -
107 		recentData.DateTime).TotalSeconds / 3600;
108         }
109 
110         var addDataResult = await _turbineDataRepository
111 		.AddDataAsync(model);
112         if (!addDataResult)
113             return TurbineStatus.None;
114 
115         if(recentData is null)
116             return await _turbineDataHelper
117 		.UpdateTurbineStatusNewAsync(turbine, model);
118 
119         return await _turbineDataHelper
120 		.UpdateTurbineStatusAsync(turbine, model, recentData);
121     }
122 
123     public async Task<bool> DeleteDataAsync(int dataId)
124     {
125         return await _turbineDataRepository.DeleteDataAsync(dataId);
126     }
127 }



Б.2 Код допоміжного сервісу TurbineDataHelper

1 using WindSync.BLL.Dtos;
2 using WindSync.BLL.Services.AlertService;
3 using WindSync.Core.Enums;
4 using WindSync.Core.Models;
5 using WindSync.DAL.Repositories.TurbineRepository;
6 
7 namespace WindSync.BLL.Services.TurbineDataService;
8 
9 public class TurbineDataHelper : ITurbineDataHelper
10 {
11     private readonly ITurbineRepository
12 	_turbineRepository;
13     private readonly IAlertService _alertService;
14 
15     public TurbineDataHelper(
16 	ITurbineRepository turbineRepository,
17 	IAlertService alertService)
18     {
19         _turbineRepository = turbineRepository;
20         _alertService = alertService;
21     }
22 
23     public async Task<TurbineStatus>
24 	UpdateTurbineStatusNewAsync(Turbine turbine,
25 	TurbineData currentData)
26     {
27         var resultStatus = turbine.Status;
28 
29         if (turbine.Status != TurbineStatus.Operational
30 	&& turbine.Status != TurbineStatus.Idle)
31             return resultStatus;
32 
33         if (IsBelowCutInWindSpeed(turbine,
34 	currentData.WindSpeed))
35         {
36             var result = await _turbineRepository
37 		.ChangeTurbineStatusAsync(turbine.Id,
38 		TurbineStatus.Idle);
39 
40             if (result)
41             {
42                 resultStatus = TurbineStatus.Idle;
43                 await SendAlert("Speed of wind is below cut-in speed.
44 		Turbine status is changed to Idle.",
45                     AlertStatus.Informational,
46                     turbine);
47             }
48         }
49         else if (IsShutDownWindSpeed(turbine,
50 	currentData.WindSpeed))
51         {
52             var result = await _turbineRepository
53 		.ChangeTurbineStatusAsync(turbine.Id, TurbineStatus.Idle);
54 
55             if (result)
56             {
57                 resultStatus = TurbineStatus.Idle;
58                 await SendAlert("Speed of wind is greater
59 		than shutdown speed.
60 		Turbine status is changed to Idle.",
61                     AlertStatus.Warning,
62                     turbine);
63             }
64         }
65         else if (IsCutInWindSpeed(turbine,
66 		currentData.WindSpeed))
67         {
68             var result = await _turbineRepository
69 		.ChangeTurbineStatusAsync(turbine.Id,
70 		TurbineStatus.Operational);
71 
72             if (result)
73             {
74                 resultStatus = TurbineStatus.Operational;
75                 await SendAlert("Speed of wind is in cut-in speed.
76 		Turbine status is unchanged.",
77                     AlertStatus.Informational,
78                     turbine);
79             }
80         }
81         else if (IsRatedWindSpeed(turbine,
82 	currentData.WindSpeed))
83         {
84             var result = await _turbineRepository
85 		.ChangeTurbineStatusAsync(turbine.Id,
86 		TurbineStatus.Operational);
87 
88             if (result)
89             {
90                 resultStatus = TurbineStatus.Operational;
91                 await SendAlert("Speed of wind is in rated speed.
92 		Turbine status is unchanged.
93 		Turbine power output is restricted.",
94                     AlertStatus.Informational,
95                     turbine);
96             }
97         }
98 
99         return resultStatus;
100     }
101 
102     public async Task<TurbineStatus>
103 	UpdateTurbineStatusAsync(Turbine turbine,
104 	TurbineData currentData,
105 	TurbineData recentData)
106     {
107         var resultStatus = turbine.Status;
108 
109         if (turbine.Status != TurbineStatus.Operational
110 	&& turbine.Status != TurbineStatus.Idle)
111             return resultStatus;
112 
113         if (IsBelowCutInWindSpeed(turbine,
114 	currentData.WindSpeed)
115             && !IsBelowCutInWindSpeed(turbine,
116 	recentData.WindSpeed))
117         {
118             var result = await _turbineRepository
119 		.ChangeTurbineStatusAsync(turbine.Id,
120 		TurbineStatus.Idle);
121 
122             if (result)
123             {
124                 resultStatus = TurbineStatus.Idle;
125                 await SendAlert("Speed of wind is below cut-in speed.
126 		Turbine status is changed to Idle.",
127                     AlertStatus.Informational,
128                     turbine);
129             }
130         }
131         else if (IsShutDownWindSpeed(turbine,
132 		currentData.WindSpeed)
133             && !IsShutDownWindSpeed(turbine,
134 		recentData.WindSpeed))
135         {
136             var result = await _turbineRepository
137 		.ChangeTurbineStatusAsync(turbine.Id, TurbineStatus.Idle);
138 
139             if (result)
140             {
141                 resultStatus = TurbineStatus.Idle;
142                 await SendAlert("Speed of wind is greater
143 		than shutdown speed.
144 		Turbine status is changed to Idle.",
145                     AlertStatus.Warning,
146                     turbine);
147             }
148         }
149         else if (IsCutInWindSpeed(turbine,
150 		currentData.WindSpeed)
151             && IsRatedWindSpeed(turbine,
152 		recentData.WindSpeed))
153         {
154             await SendAlert("Speed of wind is in cut-in speed.
155 		Turbine status is unchanged.",
156                     AlertStatus.Informational,
157                     turbine);
158         }
159         else if (IsRatedWindSpeed(turbine,
160 		currentData.WindSpeed)
161             && IsCutInWindSpeed(turbine,
162 		recentData.WindSpeed))
163         {
164             await SendAlert("Speed of wind is in rated speed.
165 		Turbine status is unchanged.
166 		Turbine power output is restricted.",
167                     AlertStatus.Informational,
168                     turbine);
169         }
170         else if ((IsCutInWindSpeed(turbine, currentData.WindSpeed)
171 	|| IsRatedWindSpeed(turbine, currentData.WindSpeed))
172             && (IsBelowCutInWindSpeed(turbine, recentData.WindSpeed)
173 	|| IsShutDownWindSpeed(turbine, recentData.WindSpeed)))
174         {
175             var result = await _turbineRepository
176 		.ChangeTurbineStatusAsync(turbine.Id,
177 		TurbineStatus.Operational);
178 
179             if (result)
180             {
181                 resultStatus = TurbineStatus.Operational;
182                 await SendAlert("Speed of wind is
183 		in cut-in/rated speed.
184 		Turbine status is changed from Idle to Operational.",
185                     AlertStatus.Resolved,
186                     turbine);
187             }
188         }
189 
190         return resultStatus;
191     }
192 
193     public bool IsBelowCutInWindSpeed(
194 	Turbine turbine,
195 	double windSpeed)
196 	=> windSpeed < turbine.CutInWindSpeed;
197 
198     public bool IsCutInWindSpeed(
199 	Turbine turbine,
200 	double windSpeed)
201 	=> windSpeed >= turbine.CutInWindSpeed && windSpeed
202 	< turbine.RatedWindSpeed;
203 
204     public bool IsRatedWindSpeed(
205 	Turbine turbine,
206 	double windSpeed)
207 	=> windSpeed >= turbine.RatedWindSpeed && windSpeed
208 	< turbine.ShutDownWindSpeed;
209 
210     public bool IsShutDownWindSpeed(
211 	Turbine turbine,
212 	double windSpeed)
213 	=> windSpeed >= turbine.ShutDownWindSpeed;
214 
215     public async Task SendAlert(
216 	string message,
217 	AlertStatus status,
218 	Turbine turbine)
219     {
220         var alert = new AlertDto()
221         {
222             Message = $"Turbine: {turbine.Id}\n
223 		WindFarm: {turbine.WindFarmId}\n{message}",
224             DateTime = DateTime.UtcNow,
225             Status = status,
226             UserId = turbine.WindFarm.UserId
227         };
228         await _alertService.AddAlertAsync(alert);
229     }
230 }
 
ДОДАТОК В
Код ІоТ девайсу

В.1 Код класу NetworkService

1 import network
2 import constants
3 import time
4 
5 class NetworkService:
6     def __init__(self):
7         self.wlan = network.WLAN(network.STA_IF)
8 
9     def connect_to_network(self):
10         self.wlan.active(True)
11         if not self.wlan.isconnected():
12             print("Connecting to network", end = "")
13             self.wlan.connect(constants.WIFI_SSID,
14 		constants.WIFI_PASSWORD)
15             while not self.wlan.isconnected():
16                 print(".", end = "")
17                 time.sleep(0.1)
18         print("\nNetwork config:", self.wlan.ifconfig())
19 
20     def configure_network(self):
21         constants.CLEAR()
22 
23         print("0 - Quit")
24         print("1 - Change SSID")
25         print("2 - Change Password")
26         print("3 - Remove Password")
27         action = input(">>> ")
28 
29         if action == "0":
30             return
31         elif action == "1":
32             self.__change_ssid()
33         elif action == "2":
34             self.__change_password()
35         elif action == "3":
36             self.__remove_password()
37         else:
38             self.configure_network()
39 
40     def __change_ssid(self):
41         constants.CLEAR()
42 
43         ssid = input("New ssid >> ")
44         constants.WIFI_SSID = ssid;
45 
46         self.configure_network()
47 
48     def __change_password(self):
49         constants.CLEAR()
50 
51         password = input("New password >>> ")
52         constants.WIFI_PASSWORD = password;
53 
54         self.configure_network()
55 
56     def __remove_password(self):
57         constants.CLEAR()
58 
59         constants.WIFI_PASSWORD = None;
60 
61         self.configure_network()

В.2 Код класу HttpService

1 import urequests
2 import constants
3 import time
4 import json
5 from profile_service import ProfileService
6 
7 class HttpService:
8     def __init__(self):
9         self.profile_service = ProfileService()
10 
11     def login(self, email, password):
12         url = f"{constants.API_URL}/
13 	{constants.LOGIN_ENDPOINT}"
14 
15         payload = {
16             "email": email,
17             "password": password
18         }
19 
20         headers = {
21             "Content-Type": "application/json",
22             "ngrok-skip-browser-warning": "true"
23             }
24 
25         response = urequests.post(url,
26 	json=payload, headers=headers)
27 
28         if response.status_code == 200:
29             self.profile_service.set_access_token
30 		(response.text)
31             return True
32         else:
33             return False
34 
35     def get_my_turbines(self):
36         url = f"{constants.API_URL}/
37 		{constants.TURBINES_MY_ENDPOINT}"
38         headers = {
39             "Authorization": f"Bearer
40 		{constants.ACCESS_TOKEN}",
41             "ngrok-skip-browser-warning": "true"
42             }
43 
44         response = urequests.get(url, headers=headers)
45 
46         if response.status_code == 200:
47             return json.loads(response.text)
48         else:
49             return []
50 
51     def add_turbine_data(self,
52 	turbine_id, temperature, wind_speed):
53         url = f"{constants.API_URL}/
54 	{constants.TURBINE_DATA_ADD_ENDPOINT}"
55 
56         temperature = temperature + 273
57 
58         payload = {
59             "turbineId": turbine_id,
60             "airTemperature": temperature,
61             "windSpeed": wind_speed
62         }
63 
64         headers = {
65             "Content-Type": "application/json",
66             "Authorization": f"Bearer
67 		{constants.ACCESS_TOKEN}",
68             "ngrok-skip-browser-warning": "true"
69             }
70 
71         response = urequests.post(url,
72 		json=payload, headers=headers)
73 
74         if response.status_code == 200:
75             self.profile_service
76 		.set_turbine_status(int(response.text))
77             return True
78         else:
79             return False
80

В.3 Код класу ProfileService

1 import constants
2 
3 class ProfileService:
4     def __init__(self):
5         return
6 
7     def set_access_token(self, token):
8         constants.ACCESS_TOKEN = token
9 
10     def set_turbine_id(self, turbine_id):
11         constants.TURBINE_ID = turbine_id
12 
13     def set_turbine_status(self, turbine_status):
14         constants.CURRENT_TURBINE_STATUS
15 	= turbine_status

В.4 Код класу WindSyncService

1 import constants
2 import dht
3 import time
4 from machine import Pin
5 from network_service import NetworkService
6 from http_service import HttpService
7 from profile_service import ProfileService
8 
9 class WindSyncService:
10     def __init__(self):
11         self.network_service = NetworkService()
12         self.http_service = HttpService()
13         self.profile_service = ProfileService()
14         self.sensor = dht.DHT22(Pin(15))
15 
16     def main(self):
17         constants.CLEAR()
18 
19         print("Welcome to WindSync Smart Device!")
20         print("1 - Network settings")
21         print("2 - Log in")
22         action = input(">>> ")
23 
24         constants.CLEAR()
25 
26         if action == "1":
27             self.network_service.configure_network()
28             self.main()
29         elif action == "2":
30             self.__login()
31         else:
32             self.main()
33 
34     def __login(self):
35         self.network_service.connect_to_network()
36 
37         email = input("Email >>> ")
38         password = input("Password >>> ")
39         login_result = self.http_service.login
40 	(email, password)
41 
42         if login_result:
43             print("Login successful!")
44             constants.WAIT()
45             self.__configuration()
46         else:
47             print("Login error...")
48             constants.WAIT()
49             self.main()
50 
51     def __configuration(self):
52         constants.CLEAR()
53 
54         print(f"Turbine ID: {constants.TURBINE_ID}")
55         print(f"Logging period:
56 	{constants.LOGGING_PERIOD}")
57 
58         print("1 - Start logging")
59         print("2 - Change turbine ID")
60         print("3 - Change logging period")
61         action = input(">>> ")
62 
63         if action == "1":
64             self.__start_logging()
65         elif action == "2":
66             self.__change_turbine_id()
67         elif action == "3":
68             self.__change_logging_period()
69         else:
70             self.__configuration()
71 
72 
73     def __change_turbine_id(self):
74         constants.CLEAR()
75 
76         turbines = self.http_service.get_my_turbines()
77         print("My available turbines:")
78 
79         for turbine in turbines:
80             print(f"ID: {turbine['id']}\tWindFarm ID:
81 	{turbine['windFarmId']}")
82 
83         turbine_id = input("New turbine ID >>> ")
84         self.profile_service.set_turbine_id(turbine_id)
85 
86         self.__configuration()
87 
88     def __change_logging_period(self):
89         constants.CLEAR()
90 
91         period = input("New logging period
92 	(in seconds) >>> ")
93         constants.LOGGING_PERIOD = int(period)
94         self.__configuration()
95 
96     def __start_logging(self):
97         while True:
98             constants.CLEAR()
99 
100             self.sensor.measure()
101             print("Measuring temperature and wind speed...")
102 
103             turbine_id = constants.TURBINE_ID
104             temperature = self.sensor.temperature()
105             wind_speed = self.sensor.humidity() / 2
106 
107             print("Data measured:")
108 
109             print(f"\ttemperature: {temperature}")
110             print(f"\twind speed: {wind_speed}")
111 
112             print("Logging data...")
113             log_result = self.http_service
114 		.add_turbine_data(turbine_id,
115 		temperature, wind_speed)
116             if log_result:
117                 print("Data log successful!")
118                 print(f"Current turbine status:
119 		{constants.TURBINE_STATUS[
120 		constants.CURRENT_TURBINE_STATUS]}")
121             else:
122                 print("Data log error...")
123 
124             time.sleep(constants.LOGGING_PERIOD)
 
ДОДАТОК Г
Код веб-застосунку

Г.1 Код компоненту FarmsDetailsComponent

1 @Component({
2   selector: 'app-farms.details',
3   standalone: true,
4   imports: [
5     JsonPipe,
6     MatCardModule,
7     MatButtonModule,
8     MatTableModule,
9     MatIconModule,
10     CommonModule,
11     TurbinesDetailsComponent,
12     MatDividerModule,
13     NgIf
14   ],
15   templateUrl: './farms.details.component.html',
16   animations: [
17     trigger('detailExpand', [
18       state('collapsed,void',
19 style({height: '0px', minHeight: '0'})),
20       state('expanded', style({height: '*'})),
21       transition('expanded <=>
22 collapsed', animate('225ms cubic-bezier(0.4, 0.0, 0.2, 1)')),
23     ]),
24   ],
25   styleUrl: './farms.details.component.scss'
26 })
27 export class FarmsDetailsComponent
28 implements OnInit {
29   private farmService = inject(FarmService);
30   private authService = inject(AuthService);
31   private turbineService = inject(TurbineService);
32   private router = inject(Router);
33   private route = inject(ActivatedRoute);
34   private dialog = inject(MatDialog);
35 
36   isAdmin: boolean = false;
37 
38   farmId!: number;
39   farm!: FarmReadViewModel;
40   turbines: TurbineReadViewModel[] = [];
41   operationalTurbinesCount: number = 0;
42 
43   turbinesCombinedData: TurbineDataReadViewModel = {
44     id: 0,
45     dateTime: new Date(),
46     windSpeed: 0,
47     ratedPower: 0,
48     powerOutput: 0,
49     airDensity: 0,
50     airPressure: 0,
51     airTemperature: 0
52   };
53 
54   turbinesDisplayedColumns: string[] =
55 ['id', 'turbineRadius', 'sweptArea',
56 'latitude', 'longitude', 'altitude', 'efficiency'];
57   turbinesColumnNames: { [key: string]: string } = {
58     'id': 'Id',
59     'turbineRadius': 'TurbineRadius',
60     'sweptArea': 'SweptArea',
61     'latitude': 'Latitude',
62     'longitude': 'Longitude',
63     'altitude': 'Altitude',
64     'efficiency': 'Efficiency',
65   };
66   turbinesDisplayedColumnsWithExpand = 
67 [...this.turbinesDisplayedColumns, 'expand'];
68   expandedTurbine?: TurbineReadViewModel;
69 
70   ngOnInit(): void {
71     this.farmId = this.route.snapshot.params['farm-id'] 
72 as number;
73 
74     this.isAdmin = this.authService.getIsAdmin();
75 
76     this.farmService.getById(this.farmId)
77       .subscribe(result => {
78         this.farm = result;
79       });
80 
81     this.farmService.getTurbines(this.farmId)
82       .subscribe(result => {
83         this.turbines = result;
84         this.operationalTurbinesCount = 
85 this.turbines.filter(t => t.status === 1).length;
86         this.getStats();
87       });
88   }
89 
90   getStats() {
91     const today = new Date();
92     const start = new Date(today.setHours(0, 0, 0, 0));
93     const end = new Date(today.setHours(23, 59, 59, 999));
94 
95     this.farmService.getTurbines(this.farmId)
96 .subscribe(turbines => {
97       this.turbines = turbines;
98   
99       const turbineDataRequests = 
100 this.turbines.map(turbine => {
101         return this.turbineService
102 .getDataHistorical(turbine.id, start, end);
103       });
104   
105       forkJoin(turbineDataRequests)
106 .subscribe(allData => {
107         const totalDataPoints = 
108 allData.reduce((acc, data) => acc + data.length, 0);
109   
110         let totalWindSpeed = 0;
111         let totalRatedPower = 0;
112         let totalPowerOutput = 0;
113 
114         allData.forEach(data => {
115           data.forEach(d => {
116             totalWindSpeed += d.windSpeed;
117             totalRatedPower += d.ratedPower;
118             totalPowerOutput += d.powerOutput;
119           });
120         });
121   
122         this.turbinesCombinedData.windSpeed = 
123 totalWindSpeed / totalDataPoints;
124         this.turbinesCombinedData.ratedPower = 
125 Number(((totalRatedPower / totalDataPoints) / 
126 1000000).toFixed(3));
127         this.turbinesCombinedData.powerOutput = 
128 Number((totalPowerOutput / 1000000).toFixed(3));
129       });
130     });
131   }
132 
133   onAddTurbine() {
134     this.router
135 .navigate(['farms', this.farmId, 'turbines', 'add']);
136   }
137 
138   onFarmUpdate() {
139     this.router.navigate(['farms', 'update', 
140 this.farmId]);
141   }
142 
143   onFarmDelete(): void {
144     const dialogRef = this.dialog
145 .open(FarmsDeleteComponent);
146 
147     dialogRef.afterClosed().subscribe((result) => {
148       if (result) {
149         this.farmService.delete(this.farmId!)
150           .subscribe(() => {
151             this.router.navigate(['farms']);
152           });
153       }
154     });
155   }
156 }

Г.2 Код компоненту TurbinesDetailsComponent

1 @Component({
2   selector: 'app-turbines-details',
3   standalone: true,
4   imports: [
5     JsonPipe,
6     NgApexchartsModule,
7     MatButtonModule,
8     NgIf
9   ],
10   templateUrl: './turbines.details.component.html',
11   styleUrl: './turbines.details.component.scss'
12 })
13 export class TurbinesDetailsComponent
14 implements OnInit {
15   private turbineService = 
16 inject(TurbineService);
17   private authService = inject(AuthService);
18   private router = inject(Router);
19   private dialog = inject(MatDialog);
20 
21   @Input() turbine!: TurbineReadViewModel;
22   TurbineStatus = TurbineStatus;
23 
24   @ViewChild("chart") chart!: ChartComponent;
25   public chartOptions!: Partial<ChartOptions>;
26 
27   isAdmin: boolean = false;
28 
29   turbineData: TurbineDataReadViewModel[] = [];
30 
31   ngOnInit(): void {
32     this.isAdmin = this.authService.getIsAdmin();
33 
34     this.turbineService
35 .getDataHistorical(this.turbine.id, 
36 new Date('2024-01-01'), 
37 new Date('2024-06-01'))
38       .subscribe(result => {
39         this.turbineData = result.sort((a, b) =>{
40           if(!a.dateTime || a.dateTime < b.dateTime)
41             return -1
42           else if (!b.dateTime || 
43 a.dateTime > b.dateTime)
44             return 1
45           return 0
46       });
47         this.updateChart(this.turbineData);
48       });
49   }
50 
51   onUpdateTurbine() {
52     this.router.navigate(['farms', 
53 this.turbine.windFarmId, 'turbines', 
54 'update', this.turbine.id]);
55   }
56 
57   onDeleteTurbine(): void {
58     const dialogRef = this.dialog
59 .open(TurbinesDeleteComponent);
60 
61     dialogRef.afterClosed()
62 .subscribe((result) => {
63       if (result) {
64         this.turbineService
65 .delete(this.turbine.id)
66           .subscribe(() => {
67             this.router.navigate(['farms'], 
68 { skipLocationChange: true })
69               .then(() => this.router
70 .navigate(['farms', this.turbine.windFarmId]));
71           });
72       }
73     });
74   }
75 
76   updateChart(data: TurbineDataReadViewModel[]){
77     this.chartOptions = {
78       series: [
79         {
80           name: "Rated Power",
81           data: data.map(d => d.ratedPower),
82           color: '#3F51B5'
83         }
84       ],
85       chart: {
86         height: 350,
87         type: "area",
88         toolbar: {
89           show: true,
90           offsetX: 0,
91           offsetY: 0,
92           tools: {
93             download: true,
94             selection: false,
95             zoom: false,
96             zoomin: true,
97             zoomout: true,
98             pan: false,
99             reset: false,
100             customIcons: []
101           },
102           autoSelected: 'zoom' 
103         },
104       },
105       dataLabels: {
106         enabled: false
107       },
108       stroke: {
109         curve: "smooth"
110       },
111       xaxis: {
112         type: "datetime",
113         categories: data.map(d => d.dateTime)
114       },
115       yaxis: {
116         labels: {
117           formatter: function (val) {
118             return val.toFixed(0);
119           }
120         }
121       },
122       tooltip: {
123         x: {
124           format: "dd/MM/yy HH:mm"
125         }
126       }
127     };
128   }
129 }
130 
131 export type ChartOptions = {
132   series: ApexAxisChartSeries;
133   chart: ApexChart;
134   xaxis: ApexXAxis;
135   yaxis: ApexYAxis;
136   stroke: ApexStroke;
137   tooltip: ApexTooltip;
138   dataLabels: ApexDataLabels;
139 };
 
ДОДАТОК Д
Код мобільного застосунку

Д.1 Код сервісу ApiService

1 using Microsoft.Maui
2 .Controls.PlatformConfiguration;
3 using System.Diagnostics;
4 using System.Net.Http.Headers;
5 using System.Text;
6 using System.Text.Json;
7 using WindSyncApp.Models;
8 using WindSyncApp.Utils;
9 
10 namespace WindSyncApp.Services;
11 
12 public class ApiService : IApiService
13 {
14     private readonly HttpClient _httpClient;
15     private readonly string _baseAddress;
16     private readonly string _url;
17     private readonly 
18 JsonSerializerOptions _jsonSerializerOptions;
19 
20     public ApiService(HttpClient httpClient)
21     {
22         _httpClient = httpClient;
23         _baseAddress = DeviceInfo.Platform 
24 == DevicePlatform.Android ?"http://10.0.2.2:5006":"http://localhost:5006";
25         _url = $"{_baseAddress}/api";
26 
27         _jsonSerializerOptions 
28 = new JsonSerializerOptions
29         {
30             PropertyNamingPolicy 
31 = JsonNamingPolicy.CamelCase
32         };
33     }
34 
35     public async Task<bool> 
36 LoginAsync(string email, string password)
37     {
38         if (!CheckInternetConnection())
39             return false;
40 
41         try
42         {
43             var json = JsonSerializer
44 .Serialize(new { email, password }, _jsonSerializerOptions);
45             var content = new StringContent
46 (json, Encoding.UTF8, "application/json");
47 
48             var response = await _httpClient
49 .PostAsync($"{_url}/auth/login", content);
50 
51             if (!CheckHttpRequestSuccess
52 (response, nameof(LoginAsync)))
53                 return false;
54 
55             var token = await response
56 .Content.ReadAsStringAsync();
57             await SecureStorage
58 .SetAsync(Constants.AuthToken, token);
59 
60             return response.IsSuccessStatusCode;
61         }
62         catch (Exception ex)
63         {
64             HandleException(ex);
65         }
66 
67         return false;
68     }
69 
70     public bool IsAuthenticated()
71     {
72         //SecureStorage.RemoveAll();
73 
74         var token = SecureStorage
75 .GetAsync(Constants.AuthToken).Result;
76         return !string.IsNullOrEmpty(token);
77     }
78 
79     public async Task<List<Turbine>> 
80 GetMyTurbinesAsync()
81     {
82         var turbines = new List<Turbine>();
83 
84         if (!CheckInternetConnection())
85             return turbines;
86 
87         try
88         {
89             _httpClient.DefaultRequestHeaders
90 .Authorization = new AuthenticationHeaderValue
91 ("Bearer", await GetAuthToken());
92 
93             var response = await _httpClient
94 .GetAsync($"{_url}/turbines/my");
95 
96             if (!CheckHttpRequestSuccess
97 (response, nameof(GetMyTurbinesAsync)))
98                 return turbines;
99 
100             var content = await response
101 .Content.ReadAsStringAsync();
102             turbines = JsonSerializer
103 .Deserialize<List<Turbine>>(content, _jsonSerializerOptions);
104         }
105         catch (Exception ex)
106         {
107             HandleException(ex);
108         }
109 
110         return turbines;
111     }
112 
113     public async Task<List<TurbineData>> 
114 GetTurbineDataAsync(int turbineId, DateTime start, DateTime end)
115     {
116         var turbineData = new List<TurbineData>();
117         if (!CheckInternetConnection())
118             return turbineData;
119 
120         try
121         {
122             _httpClient.DefaultRequestHeaders
123 .Authorization 
124 = new AuthenticationHeaderValue
125 ("Bearer", await GetAuthToken());
126             var response = await _httpClient
127.GetAsync($"{_url}/turbines/{turbineId}/data?start={start:O}&end={end:O}")
128 
129             if (!CheckHttpRequestSuccess
130 (response, nameof(GetTurbineDataAsync)))
131                 return turbineData;
132 
133             var content = await response
134 .Content.ReadAsStringAsync();
135             turbineData = JsonSerializer
136 .Deserialize<List<TurbineData>>(content, 
137 _jsonSerializerOptions);
138         }
139         catch (Exception ex)
140         {
141             HandleException(ex);
142         }
143 
144         return turbineData;
145     }
146 
147     public async Task<UserInfo> 
148 GetUserProfileAsync()
149     {
150         var user = new UserInfo();
151 
152         if (!CheckInternetConnection())
153             return user;
154 
155         try
156         {
157             _httpClient.DefaultRequestHeaders
158 .Authorization = new 
159 AuthenticationHeaderValue("Bearer", 
160 await GetAuthToken());
161 
162             var response = await _httpClient
163 .GetAsync($"{_url}/auth");
164 
165             if (!CheckHttpRequestSuccess
166 (response, nameof(GetUserProfileAsync)))
167                 return user;
168 
169             var content = await response
170 .Content.ReadAsStringAsync();
171             user = JsonSerializer
172 .Deserialize<UserInfo>(content, _jsonSerializerOptions);
173         }
174         catch (Exception ex)
175         {
176             HandleException(ex);
177         }
178 
179         return user;
180     }
181 
182     public async Task<List<Alert>> 
183 GetMyAlertsAsync()
184     {
185         var alerts = new List<Alert>();
186 
187         if (!CheckInternetConnection())
188             return alerts;
189 
190         try
191         {
192             _httpClient.DefaultRequestHeaders
193 .Authorization 
194 = new AuthenticationHeaderValue
195 ("Bearer", await GetAuthToken());
196 
197             var response = await 
198 _httpClient.GetAsync($"{_url}/alerts");
199 
200             if (!CheckHttpRequestSuccess
201 (response, nameof(GetMyAlertsAsync)))
202                 return alerts;
203 
204             var content = await response
205 .Content.ReadAsStringAsync();
206             alerts = JsonSerializer
207 .Deserialize<List<Alert>>(content, _jsonSerializerOptions);
208         }
209         catch (Exception ex)
210         {
211             HandleException(ex);
212         }
213 
214         return alerts;
215     }
216 
217     private async Task<string> 
218 GetAuthToken()
219     {
220         return await SecureStorage
221 .GetAsync(Constants.AuthToken);
222     }
223 
224     private bool CheckInternetConnection()
225     {
226         if (Connectivity.Current
227 .NetworkAccess != NetworkAccess.Internet)
228         {
229             Debug
230 .WriteLine("---> No internet access.");
231             return false;
232         }
233 
234         return true;
235     }
236 
237     private void HandleException(Exception ex)
238     {
239         Debug
240 .WriteLine($"---> Exception occured: {ex.Message}.");
241     }
242 
243     private bool 
244 CheckHttpRequestSuccess(HttpResponseMessage response, 
245 string methodName)
246     {
247         if (response.IsSuccessStatusCode)
248         {
249             Debug
250 .WriteLine($"---> {methodName} success.");
251             return true;
252         }
253         else
254         {
255             Debug
256 .WriteLine($"---> {methodName} error: {response.StatusCode}.");
257             return false;
258         }
259     }
260 }

Д.2 Код класу сторінки TurbinesPage

1 using System.Collections.ObjectModel;
2 using System.ComponentModel;
3 using System.Runtime.CompilerServices;
4 using WindSyncApp.Models;
5 using WindSyncApp.Services;
6 
7 namespace WindSyncApp.Views;
8 
9 public partial class TurbineDetailsPage 
10 : ContentPage, INotifyPropertyChanged
11 {
12     private readonly IApiService _apiService;
13     private Turbine Turbine;
14     private ObservableCollection<TurbineData> 
15 _turbineData;
16 
17     public ObservableCollection<TurbineData> 
18 TurbineData
19     {
20         get => _turbineData;
21         set
22         {
23             _turbineData = value;
24             OnPropertyChanged();
25         }
26     }
27 
28     public TurbineDetailsPage
29 (Turbine turbine)
30     {
31         InitializeComponent();
32         BindingContext = this;
33         Turbine = turbine;
34 
35         _apiService 
36 = new ApiService(new HttpClient());
37         TurbineData 
38 = new ObservableCollection<TurbineData>();
39 
40         SetTurbineLabels();
41     }
42 
43     protected override async void 
44 OnAppearing()
45     {
46         base.OnAppearing();
47         await LoadData();
48     }
49 
50     protected async Task LoadData()
51     {
52         var end = DateTime.UtcNow;
53         var start = end.AddMonths(-2);
54 
55         var turbineData = await _apiService
56 .GetTurbineDataAsync(Turbine.Id, start, end);
57 
58         TurbineData.Clear();
59         foreach (var data in turbineData)
60         {
61             TurbineData.Add(data);
62         }
63     }
64 
65     private void SetTurbineLabels()
66     {
67         IdLabel.Text = Turbine.Id.ToString();
68         StatusLabel.Text = Turbine.Status
69 .ToString();
70         RadiusLabel.Text = Turbine.TurbineRadius
71 .ToString();
72         SweptAreaLabel.Text = Turbine.SweptArea
73 .ToString();
74         LatitudeLabel.Text = Turbine.Latitude
75 .ToString();
76         LongitudeLabel.Text = Turbine.Longitude
77 .ToString();
78         AltitudeLabel.Text = Turbine.Altitude
79 .ToString();
80         EfficiencyLabel.Text = Turbine.Efficiency
81 .ToString();
82     }
83 
84     public event PropertyChangedEventHandler 
85 PropertyChanged;
86     protected void OnPropertyChanged
87 ([CallerMemberName] string propertyName = null)
88     {
89         PropertyChanged?.Invoke(this, 
90 new PropertyChangedEventArgs(propertyName));
91     }
92 }